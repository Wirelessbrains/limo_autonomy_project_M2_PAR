#!/usr/bin/env python3
import argparse
import csv
import math
import os
import warnings
from typing import List, Optional, Tuple

import matplotlib
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

matplotlib.use("Agg")
import matplotlib.pyplot as plt

warnings.filterwarnings(
    "ignore",
    message=r"A NumPy version >=1\.17\.3 and <1\.25\.0 is required for this version of SciPy.*",
    category=UserWarning,
)

try:
    from scipy.spatial import cKDTree  # type: ignore
except Exception:
    cKDTree = None


def load_traj_csv(path: str) -> pd.DataFrame:
    df = pd.read_csv(path)
    required = ["stamp_sec", "stamp_nanosec", "x", "y", "z", "qx", "qy", "qz", "qw"]
    missing = [c for c in required if c not in df.columns]
    if missing:
        raise RuntimeError(f"Missing columns in {path}: {missing}")
    if df.empty:
        raise RuntimeError(f"Empty trajectory CSV: {path}")
    return df


def resolve_traj_input_path(path_or_dir: str) -> str:
    p = os.path.abspath(path_or_dir)
    if os.path.isfile(p):
        return p
    if os.path.isdir(p):
        c = os.path.join(p, "trajetoria_camera.csv")
        if os.path.exists(c):
            return c
        raise RuntimeError(
            f"Directory '{p}' does not contain trajetoria_camera.csv. "
            "Pass the CSV path directly or a directory generated by build_tag_map_offline.py."
        )
    raise RuntimeError(f"Input path does not exist: {path_or_dir}")


def infer_query_bag_path(query_input: str) -> str:
    p = os.path.abspath(query_input)
    if os.path.isfile(p) and p.endswith(".db3"):
        return p
    if not os.path.isdir(p):
        return ""
    meta = os.path.join(p, "metadata.yaml")
    if os.path.exists(meta):
        return p
    db3s = sorted([f for f in os.listdir(p) if f.endswith(".db3")])
    if len(db3s) == 1:
        return os.path.join(p, db3s[0])
    return ""


def load_tags_csv(path: str) -> pd.DataFrame:
    df = pd.read_csv(path)
    required = ["tag", "x", "y", "z", "qx", "qy", "qz", "qw"]
    missing = [c for c in required if c not in df.columns]
    if missing:
        raise RuntimeError(f"Missing columns in {path}: {missing}")
    if df.empty:
        raise RuntimeError(f"Empty tags CSV: {path}")
    return df


def short_tag_label(tag_name: str) -> str:
    s = str(tag_name)
    return s.split(":")[-1] if ":" in s else s


def fit_similarity_2d(
    p_query: np.ndarray,
    q_ref: np.ndarray,
    allow_scale: bool,
) -> Tuple[np.ndarray, np.ndarray, float]:
    if len(p_query) != len(q_ref):
        raise RuntimeError("fit_similarity_2d: p_query and q_ref size mismatch")
    if len(p_query) < 2:
        raise RuntimeError("fit_similarity_2d: need at least 2 points")

    p_mean = p_query.mean(axis=0)
    q_mean = q_ref.mean(axis=0)
    p0 = p_query - p_mean
    q0 = q_ref - q_mean

    h = p0.T @ q0
    u, s, vt = np.linalg.svd(h)
    r = vt.T @ u.T
    if np.linalg.det(r) < 0:
        vt[1, :] *= -1
        r = vt.T @ u.T

    scale = 1.0
    if allow_scale:
        den = float(np.sum(p0 * p0))
        if den > 1e-12:
            scale = float(np.sum(s) / den)
    t = q_mean - scale * (r @ p_mean)
    return r, t, scale


def apply_similarity_2d(points_xz: np.ndarray, r: np.ndarray, t: np.ndarray, scale: float) -> np.ndarray:
    return scale * (points_xz @ r.T) + t.reshape(1, 2)


def estimate_alignment_from_tags(
    ref_tags_df: pd.DataFrame,
    query_tags_df: pd.DataFrame,
    model: str,
    ransac_thresh_m: float,
    ransac_iters: int,
) -> Tuple[np.ndarray, np.ndarray, float, float, List[str], float, int]:
    ref_map = {str(r.tag): np.array([float(r.x), float(r.z)], dtype=float) for r in ref_tags_df.itertuples(index=False)}
    qry_map = {str(r.tag): np.array([float(r.x), float(r.z)], dtype=float) for r in query_tags_df.itertuples(index=False)}
    common = sorted(set(ref_map.keys()).intersection(qry_map.keys()))
    if len(common) < 2:
        raise RuntimeError(f"Need at least 2 common tags for alignment, found {len(common)}")

    p = np.stack([qry_map[k] for k in common], axis=0)  # query
    q = np.stack([ref_map[k] for k in common], axis=0)  # reference
    allow_scale = model == "similarity"

    # RANSAC to reject outlier tags before final fit.
    rng = np.random.default_rng(42)
    best_mask = None
    best_inliers = -1
    best_med = float("inf")
    min_sample = 2
    iters = max(20, int(ransac_iters))
    for _ in range(iters):
        idx = rng.choice(len(common), size=min_sample, replace=False)
        try:
            r_try, t_try, s_try = fit_similarity_2d(p[idx], q[idx], allow_scale=allow_scale)
        except Exception:
            continue
        pred = apply_similarity_2d(p, r_try, t_try, s_try)
        err = np.linalg.norm(pred - q, axis=1)
        mask = err <= float(ransac_thresh_m)
        inliers = int(mask.sum())
        if inliers <= 0:
            continue
        med = float(np.median(err[mask]))
        if (inliers > best_inliers) or (inliers == best_inliers and med < best_med):
            best_inliers = inliers
            best_med = med
            best_mask = mask

    if best_mask is None or int(best_mask.sum()) < 2:
        # fallback: use all tags
        best_mask = np.ones(len(common), dtype=bool)

    inlier_names = [name for name, keep in zip(common, best_mask.tolist()) if keep]
    p_in = p[best_mask]
    q_in = q[best_mask]
    r, t, scale = fit_similarity_2d(p_in, q_in, allow_scale=allow_scale)
    pred_in = apply_similarity_2d(p_in, r, t, scale)
    rms = float(np.sqrt(np.mean(np.sum((pred_in - q_in) ** 2, axis=1))))
    yaw = math.atan2(float(r[1, 0]), float(r[0, 0]))
    return r, t, yaw, scale, inlier_names, rms, int(best_mask.sum())


def rot3_from_rigid2d(r2: np.ndarray) -> np.ndarray:
    # Embed XZ 2D rotation into 3D world rotation about Y with consistent signs:
    # [x', z']^T = r2 * [x, z]^T
    return np.array(
        [
            [float(r2[0, 0]), 0.0, float(r2[0, 1])],
            [0.0, 1.0, 0.0],
            [float(r2[1, 0]), 0.0, float(r2[1, 1])],
        ],
        dtype=float,
    )


def quat_from_rotmat_xyzw(r: np.ndarray) -> np.ndarray:
    tr = float(np.trace(r))
    if tr > 0.0:
        s = math.sqrt(tr + 1.0) * 2.0
        qw = 0.25 * s
        qx = (r[2, 1] - r[1, 2]) / s
        qy = (r[0, 2] - r[2, 0]) / s
        qz = (r[1, 0] - r[0, 1]) / s
    elif r[0, 0] > r[1, 1] and r[0, 0] > r[2, 2]:
        s = math.sqrt(1.0 + r[0, 0] - r[1, 1] - r[2, 2]) * 2.0
        qw = (r[2, 1] - r[1, 2]) / s
        qx = 0.25 * s
        qy = (r[0, 1] + r[1, 0]) / s
        qz = (r[0, 2] + r[2, 0]) / s
    elif r[1, 1] > r[2, 2]:
        s = math.sqrt(1.0 + r[1, 1] - r[0, 0] - r[2, 2]) * 2.0
        qw = (r[0, 2] - r[2, 0]) / s
        qx = (r[0, 1] + r[1, 0]) / s
        qy = 0.25 * s
        qz = (r[1, 2] + r[2, 1]) / s
    else:
        s = math.sqrt(1.0 + r[2, 2] - r[0, 0] - r[1, 1]) * 2.0
        qw = (r[1, 0] - r[0, 1]) / s
        qx = (r[0, 2] + r[2, 0]) / s
        qy = (r[1, 2] + r[2, 1]) / s
        qz = 0.25 * s
    q = np.array([qx, qy, qz, qw], dtype=float)
    n = float(np.linalg.norm(q))
    return q / n if n > 1e-12 else np.array([0.0, 0.0, 0.0, 1.0], dtype=float)


def rotate_heading_by_r2(query_heading_rad: np.ndarray, r2: np.ndarray) -> np.ndarray:
    c = np.cos(query_heading_rad)
    s = np.sin(query_heading_rad)
    v = np.stack([c, s], axis=1)  # [x,z] direction
    v2 = (r2 @ v.T).T
    return np.arctan2(v2[:, 1], v2[:, 0])


def normalize_angle_rad(a: np.ndarray) -> np.ndarray:
    return (a + np.pi) % (2.0 * np.pi) - np.pi


def quat_to_rotmat(qx: float, qy: float, qz: float, qw: float) -> np.ndarray:
    x, y, z, w = qx, qy, qz, qw
    return np.array(
        [
            [1 - 2 * (y * y + z * z), 2 * (x * y - z * w), 2 * (x * z + y * w)],
            [2 * (x * y + z * w), 1 - 2 * (x * x + z * z), 2 * (y * z - x * w)],
            [2 * (x * z - y * w), 2 * (y * z + x * w), 1 - 2 * (x * x + y * y)],
        ],
        dtype=float,
    )


def quat_xyzw_to_rpy_deg(q: np.ndarray) -> Tuple[float, float, float]:
    x, y, z, w = [float(v) for v in q]
    # roll (x-axis rotation)
    sinr_cosp = 2.0 * (w * x + y * z)
    cosr_cosp = 1.0 - 2.0 * (x * x + y * y)
    roll = math.atan2(sinr_cosp, cosr_cosp)

    # pitch (y-axis rotation)
    sinp = 2.0 * (w * y - z * x)
    if abs(sinp) >= 1.0:
        pitch = math.copysign(math.pi / 2.0, sinp)
    else:
        pitch = math.asin(sinp)

    # yaw (z-axis rotation)
    siny_cosp = 2.0 * (w * z + x * y)
    cosy_cosp = 1.0 - 2.0 * (y * y + z * z)
    yaw = math.atan2(siny_cosp, cosy_cosp)
    return float(math.degrees(roll)), float(math.degrees(pitch)), float(math.degrees(yaw))


def _forward_axis_vector_from_rot(r: np.ndarray, forward_axis: str) -> np.ndarray:
    axis_map = {
        "x": r[:, 0],
        "-x": -r[:, 0],
        "z": r[:, 2],
        "-z": -r[:, 2],
    }
    if forward_axis not in axis_map:
        raise RuntimeError(f"Invalid forward axis: {forward_axis}")
    return axis_map[forward_axis]


def heading_from_quat_xz(df: pd.DataFrame, forward_axis: str) -> np.ndarray:
    out = np.zeros(len(df), dtype=float)
    for i, row in enumerate(df.itertuples(index=False)):
        r = quat_to_rotmat(row.qx, row.qy, row.qz, row.qw)
        f = _forward_axis_vector_from_rot(r, forward_axis)
        out[i] = math.atan2(float(f[2]), float(f[0]))  # heading in XZ plane
    return out


def compute_ref_tangent_heading_xz(ref_xz: np.ndarray) -> np.ndarray:
    n = len(ref_xz)
    heading = np.zeros(n, dtype=float)
    for i in range(n):
        if i == 0:
            d = ref_xz[1] - ref_xz[0] if n > 1 else np.array([1.0, 0.0])
        elif i == n - 1:
            d = ref_xz[-1] - ref_xz[-2]
        else:
            d = ref_xz[i + 1] - ref_xz[i - 1]
        if float(np.linalg.norm(d)) < 1e-12:
            heading[i] = heading[i - 1] if i > 0 else 0.0
        else:
            heading[i] = math.atan2(float(d[1]), float(d[0]))
    return heading


def nearest_indices_and_distance(query_xz: np.ndarray, ref_xz: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    if cKDTree is not None:
        tree = cKDTree(ref_xz)
        dist, idx = tree.query(query_xz, k=1)
        return idx.astype(int), dist.astype(float)

    idx = np.zeros(len(query_xz), dtype=int)
    dist = np.zeros(len(query_xz), dtype=float)
    for i, p in enumerate(query_xz):
        d = np.linalg.norm(ref_xz - p, axis=1)
        j = int(np.argmin(d))
        idx[i] = j
        dist[i] = float(d[j])
    return idx, dist


def write_metrics_csv(
    out_csv: str,
    query_df: pd.DataFrame,
    t_rel_s: np.ndarray,
    nearest_idx: np.ndarray,
    distance_m: np.ndarray,
    query_heading_deg: np.ndarray,
    ref_heading_deg: np.ndarray,
    angle_error_deg: np.ndarray,
    ref_xz: np.ndarray,
    query_xz: np.ndarray,
    nearest_ref_xz_override: Optional[np.ndarray] = None,
) -> None:
    os.makedirs(os.path.dirname(out_csv), exist_ok=True)
    with open(out_csv, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(
            [
                "stamp_sec",
                "stamp_nanosec",
                "t_rel_s",
                "nearest_ref_idx",
                "distance_to_ref_m",
                "query_heading_deg",
                "ref_heading_deg",
                "heading_error_deg",
                "query_x",
                "query_z",
                "ref_x_nearest",
                "ref_z_nearest",
            ]
        )
        for i in range(len(query_df)):
            j = int(nearest_idx[i])
            if nearest_ref_xz_override is not None:
                ref_x = float(nearest_ref_xz_override[i, 0])
                ref_z = float(nearest_ref_xz_override[i, 1])
            else:
                ref_x = float(ref_xz[j, 0])
                ref_z = float(ref_xz[j, 1])
            w.writerow(
                [
                    int(query_df.iloc[i]["stamp_sec"]),
                    int(query_df.iloc[i]["stamp_nanosec"]),
                    float(t_rel_s[i]),
                    j,
                    float(distance_m[i]),
                    float(query_heading_deg[i]),
                    float(ref_heading_deg[i]),
                    float(angle_error_deg[i]),
                    float(query_xz[i, 0]),
                    float(query_xz[i, 1]),
                    ref_x,
                    ref_z,
                ]
            )


def write_html_report(
    out_html: str,
    t_rel_s: np.ndarray,
    distance_m: np.ndarray,
    angle_error_deg: np.ndarray,
    abs_angle_error_deg: np.ndarray,
    ref_xz: np.ndarray,
    query_xz: np.ndarray,
    nearest_idx: np.ndarray,
    summary_rows: List[Tuple[str, str]],
) -> None:
    os.makedirs(os.path.dirname(out_html), exist_ok=True)

    fig = make_subplots(
        rows=2,
        cols=2,
        specs=[[{"type": "xy"}, {"type": "xy"}], [{"type": "xy"}, {"type": "table"}]],
        subplot_titles=(
            "Distance to Reference Trajectory (XZ)",
            "Heading Error vs Reference Tangent",
            "Top View XZ: Query vs Reference (Color = Distance)",
            "Summary",
        ),
        vertical_spacing=0.12,
        horizontal_spacing=0.12,
    )

    fig.add_trace(
        go.Scatter(x=t_rel_s, y=distance_m, mode="lines", line=dict(color="royalblue", width=2), name="distance [m]"),
        row=1,
        col=1,
    )
    fig.add_trace(
        go.Scatter(x=t_rel_s, y=angle_error_deg, mode="lines", line=dict(color="darkorange", width=2), name="heading error [deg]"),
        row=1,
        col=2,
    )
    fig.add_trace(
        go.Scatter(x=ref_xz[:, 0], y=ref_xz[:, 1], mode="lines", line=dict(color="black", width=3), name="reference"),
        row=2,
        col=1,
    )
    fig.add_trace(
        go.Scatter(
            x=query_xz[:, 0],
            y=query_xz[:, 1],
            mode="markers",
            marker=dict(
                size=6,
                color=distance_m,
                colorscale="Viridis",
                colorbar=dict(title="distance [m]", x=0.47),
            ),
            name="query",
            text=[f"dist={d:.3f} m, |angle|={a:.2f} deg" for d, a in zip(distance_m, abs_angle_error_deg)],
            hovertemplate="x=%{x:.3f}<br>z=%{y:.3f}<br>%{text}<extra></extra>",
        ),
        row=2,
        col=1,
    )
    fig.add_trace(
        go.Scatter(
            x=[query_xz[0, 0], query_xz[-1, 0]],
            y=[query_xz[0, 1], query_xz[-1, 1]],
            mode="markers+text",
            marker=dict(size=11, color=["green", "red"]),
            text=["start", "end"],
            textposition="top center",
            name="query endpoints",
        ),
        row=2,
        col=1,
    )

    # Draw sparse linking lines to visualize nearest reference association.
    step = max(1, len(query_xz) // 120)
    for i in range(0, len(query_xz), step):
        j = int(nearest_idx[i])
        fig.add_trace(
            go.Scatter(
                x=[query_xz[i, 0], ref_xz[j, 0]],
                y=[query_xz[i, 1], ref_xz[j, 1]],
                mode="lines",
                line=dict(color="rgba(120,120,120,0.20)", width=1),
                showlegend=False,
                hoverinfo="skip",
            ),
            row=2,
            col=1,
        )

    fig.add_trace(
        go.Table(
            header=dict(values=["Metric", "Value"], fill_color="#f0f0f0", align="left"),
            cells=dict(values=[[r[0] for r in summary_rows], [r[1] for r in summary_rows]], align="left"),
        ),
        row=2,
        col=2,
    )

    fig.update_xaxes(title_text="Time [s]", row=1, col=1)
    fig.update_yaxes(title_text="Distance [m]", row=1, col=1)
    fig.update_xaxes(title_text="Time [s]", row=1, col=2)
    fig.update_yaxes(title_text="Angle Error [deg]", row=1, col=2)
    fig.update_xaxes(title_text="X [m]", row=2, col=1)
    fig.update_yaxes(title_text="Z [m]", row=2, col=1, scaleanchor="x", scaleratio=1)
    fig.update_layout(
        title="Distance and Orientation Analysis Relative to Reference Trajectory",
        height=900,
        margin=dict(l=40, r=30, t=60, b=40),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0.0),
    )
    fig.write_html(out_html, include_plotlyjs="cdn")


def percentile(x: np.ndarray, p: float) -> float:
    return float(np.percentile(x, p))


def nearest_point_on_polyline_xz(
    point_xz: np.ndarray, poly_xz: np.ndarray
) -> Tuple[np.ndarray, int, float, float, float]:
    if len(poly_xz) < 2:
        p0 = poly_xz[0]
        d = float(np.linalg.norm(point_xz - p0))
        return p0.copy(), 0, 0.0, d, 0.0

    best_d2 = float("inf")
    best_proj = poly_xz[0].copy()
    best_i = 0
    best_u = 0.0
    for i in range(len(poly_xz) - 1):
        a = poly_xz[i]
        b = poly_xz[i + 1]
        ab = b - a
        den = float(np.dot(ab, ab))
        if den < 1e-12:
            u = 0.0
            proj = a
        else:
            u = float(np.dot(point_xz - a, ab) / den)
            u = max(0.0, min(1.0, u))
            proj = a + u * ab
        d2 = float(np.dot(point_xz - proj, point_xz - proj))
        if d2 < best_d2:
            best_d2 = d2
            best_proj = proj
            best_i = i
            best_u = u
    dist = math.sqrt(best_d2)
    seg = poly_xz[best_i + 1] - poly_xz[best_i]
    heading = math.atan2(float(seg[1]), float(seg[0])) if float(np.linalg.norm(seg)) > 1e-12 else 0.0
    return best_proj, best_i, best_u, dist, heading


def quat_from_yaw_about_y(yaw_xz_rad: float) -> np.ndarray:
    # yaw in XZ plane around Y axis
    half = 0.5 * yaw_xz_rad
    qx = 0.0
    qy = math.sin(half)
    qz = 0.0
    qw = math.cos(half)
    return np.array([qx, qy, qz, qw], dtype=float)


def quat_multiply_xyzw(q1: np.ndarray, q2: np.ndarray) -> np.ndarray:
    x1, y1, z1, w1 = [float(v) for v in q1]
    x2, y2, z2, w2 = [float(v) for v in q2]
    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
    y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
    z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2
    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
    q = np.array([x, y, z, w], dtype=float)
    n = float(np.linalg.norm(q))
    return q / n if n > 1e-12 else np.array([0.0, 0.0, 0.0, 1.0], dtype=float)


def select_pointing_tags(
    robot_xyz: np.ndarray,
    robot_quat_xyzw: np.ndarray,
    tags_df: Optional[pd.DataFrame],
    forward_axis: str = "z",
    top_k: int = 2,
) -> List[Tuple[str, np.ndarray, float]]:
    if tags_df is None or tags_df.empty:
        return []
    r = quat_to_rotmat(float(robot_quat_xyzw[0]), float(robot_quat_xyzw[1]), float(robot_quat_xyzw[2]), float(robot_quat_xyzw[3]))
    optical_z = _forward_axis_vector_from_rot(r, forward_axis)
    out: List[Tuple[str, np.ndarray, float]] = []
    for row in tags_df.itertuples(index=False):
        p = np.array([float(row.x), float(row.y), float(row.z)], dtype=float)
        v = p - robot_xyz
        n = float(np.linalg.norm(v))
        if n < 1e-9:
            continue
        c = float(np.dot(optical_z, v / n))
        c = max(-1.0, min(1.0, c))
        ang = float(np.degrees(np.arccos(c)))
        if c <= 0.0:
            continue
        out.append((str(row.tag), p, ang))
    out.sort(key=lambda x: x[2])
    return out[: max(1, int(top_k))]


def infer_forward_axis_from_tags(
    robot_xyz: np.ndarray,
    robot_quat_xyzw: np.ndarray,
    tags_df: Optional[pd.DataFrame],
) -> Tuple[str, float]:
    if tags_df is None or tags_df.empty:
        return "z", 999.0
    candidates = ["x", "z", "-x", "-z"]
    r = quat_to_rotmat(float(robot_quat_xyzw[0]), float(robot_quat_xyzw[1]), float(robot_quat_xyzw[2]), float(robot_quat_xyzw[3]))

    best_axis = "z"
    best_mean = 1e9
    for axis in candidates:
        fwd = _forward_axis_vector_from_rot(r, axis)
        angs = []
        for row in tags_df.itertuples(index=False):
            p = np.array([float(row.x), float(row.y), float(row.z)], dtype=float)
            v = p - robot_xyz
            n = float(np.linalg.norm(v))
            if n < 1e-9:
                continue
            c = float(np.dot(fwd, v / n))
            c = max(-1.0, min(1.0, c))
            angs.append(float(np.degrees(np.arccos(c))))
        if not angs:
            continue
        m = float(np.mean(angs))
        if m < best_mean:
            best_mean = m
            best_axis = axis
    return best_axis, best_mean


def load_detection_tags_near_stamp(
    bag_path: str,
    detections_topic: str,
    target_stamp_ns: int,
) -> Tuple[List[str], Optional[int]]:
    try:
        from rclpy.serialization import deserialize_message  # type: ignore
        from rosbag2_py import ConverterOptions, SequentialReader, StorageOptions  # type: ignore
        from rosidl_runtime_py.utilities import get_message  # type: ignore
    except Exception as e:
        raise RuntimeError(f"ROS2 bag reader dependencies unavailable: {e}")

    reader = SequentialReader()
    reader.open(StorageOptions(uri=bag_path, storage_id="sqlite3"), ConverterOptions("", "cdr"))
    type_map = {t.name: t.type for t in reader.get_all_topics_and_types()}
    if detections_topic not in type_map:
        raise RuntimeError(f"Topic not found in bag: {detections_topic}")
    det_msg_t = get_message(type_map[detections_topic])

    best_tags: List[str] = []
    best_stamp: Optional[int] = None
    best_abs_dt = None

    while reader.has_next():
        topic, data, _ = reader.read_next()
        if topic != detections_topic:
            continue
        msg = deserialize_message(data, det_msg_t)
        stamp_ns = int(msg.header.stamp.sec) * 1_000_000_000 + int(msg.header.stamp.nanosec)
        dt = abs(stamp_ns - int(target_stamp_ns))
        if best_abs_dt is None or dt < best_abs_dt:
            best_abs_dt = dt
            best_stamp = stamp_ns
            tags = [f"{det.family}:{int(det.id)}" for det in msg.detections]
            best_tags = sorted(set(tags))
    return best_tags, best_stamp


def circular_mean_rad(angles: np.ndarray) -> float:
    s = float(np.mean(np.sin(angles)))
    c = float(np.mean(np.cos(angles)))
    return math.atan2(s, c)


def reduce_query_to_representative_point(
    query_df: pd.DataFrame,
    query_xz: np.ndarray,
    query_heading_rad: np.ndarray,
) -> Tuple[pd.DataFrame, np.ndarray, np.ndarray]:
    x_med = float(np.median(query_xz[:, 0]))
    z_med = float(np.median(query_xz[:, 1]))
    h_mean = circular_mean_rad(query_heading_rad)
    d = np.linalg.norm(query_xz - np.array([x_med, z_med], dtype=float), axis=1)
    i_closest = int(np.argmin(d))

    q = query_df.iloc[[i_closest]].copy()
    q.loc[q.index[0], "x"] = x_med
    q.loc[q.index[0], "z"] = z_med

    q_xz = np.array([[x_med, z_med]], dtype=float)
    q_heading = np.array([h_mean], dtype=float)
    return q, q_xz, q_heading


def is_static_point_capture(query_xz: np.ndarray, threshold_m: float) -> bool:
    if len(query_xz) < 2:
        return True
    center = np.mean(query_xz, axis=0)
    radial = np.linalg.norm(query_xz - center, axis=1)
    return float(np.percentile(radial, 95)) <= threshold_m


def write_html_point_report(
    out_html: str,
    ref_xyz: np.ndarray,
    robot_xyz: np.ndarray,
    nearest_ref_xyz: np.ndarray,
    robot_heading_deg: float,
    ref_heading_deg: float,
    distance_m: float,
    heading_error_deg: float,
    summary_rows: List[Tuple[str, str]],
    robot_quat_xyzw: np.ndarray,
    nearest_ref_quat_xyzw: np.ndarray,
    tags_df: Optional[pd.DataFrame] = None,
    pointing_tags_df: Optional[pd.DataFrame] = None,
    forward_axis_for_pointing: str = "z",
    tf_axis_len_m: float = 0.12,
    viz_mode: str = "student",
) -> None:
    os.makedirs(os.path.dirname(out_html), exist_ok=True)
    fig = go.Figure()

    fig.add_trace(
        go.Scatter3d(
            x=ref_xyz[:, 0],
            y=ref_xyz[:, 1],
            z=ref_xyz[:, 2],
            mode="lines",
            line=dict(color="black", width=6),
            name="reference trajectory",
        )
    )
    if tags_df is not None and not tags_df.empty:
        tag_labels = [short_tag_label(t) for t in tags_df["tag"].astype(str).tolist()]
        fig.add_trace(
            go.Scatter3d(
                x=tags_df["x"].to_numpy(dtype=float),
                y=tags_df["y"].to_numpy(dtype=float),
                z=tags_df["z"].to_numpy(dtype=float),
                mode="markers+text",
                marker=dict(size=4, color="orange"),
                text=tag_labels,
                textposition="top center",
                textfont=dict(size=10, color="rgb(60,80,120)"),
                hovertemplate="tag=%{text}<br>x=%{x:.3f}<br>y=%{y:.3f}<br>z=%{z:.3f}<extra></extra>",
                name="map tags",
            )
        )
    fig.add_trace(
        go.Scatter3d(
            x=[robot_xyz[0]],
            y=[robot_xyz[1]],
            z=[robot_xyz[2]],
            mode="markers+text",
            marker=dict(size=6, color="royalblue"),
            text=["robot point"],
            textposition="top center",
            name="robot",
        )
    )

    fig.add_trace(
        go.Scatter3d(
            x=[nearest_ref_xyz[0]],
            y=[nearest_ref_xyz[1]],
            z=[nearest_ref_xyz[2]],
            mode="markers+text",
            marker=dict(size=6, color="crimson"),
            text=["nearest on ref"],
            textposition="top center",
            name="nearest reference",
        )
    )
    fig.add_trace(
        go.Scatter3d(
            x=[robot_xyz[0], nearest_ref_xyz[0]],
            y=[robot_xyz[1], nearest_ref_xyz[1]],
            z=[robot_xyz[2], nearest_ref_xyz[2]],
            mode="lines",
            line=dict(color="darkorange", width=6, dash="dash"),
            name="distance link",
        )
    )

    if viz_mode == "debug":
        tf_legend_used = {"robot_x": False, "robot_y": False, "robot_z": False, "ref_x": False, "ref_y": False, "ref_z": False}

        def _add_tf_axes(origin_xyz: np.ndarray, quat_xyzw: np.ndarray, prefix: str) -> None:
            r = quat_to_rotmat(float(quat_xyzw[0]), float(quat_xyzw[1]), float(quat_xyzw[2]), float(quat_xyzw[3]))
            colors = [("X", "red", 0), ("Y", "green", 1), ("Z", "blue", 2)]
            for axis_name, color, axis_idx in colors:
                end = origin_xyz + tf_axis_len_m * r[:, axis_idx]
                key = f"{'robot' if prefix == 'robot' else 'ref'}_{axis_name.lower()}"
                show_leg = not tf_legend_used[key]
                tf_legend_used[key] = True
                fig.add_trace(
                    go.Scatter3d(
                        x=[origin_xyz[0], end[0]],
                        y=[origin_xyz[1], end[1]],
                        z=[origin_xyz[2], end[2]],
                        mode="lines",
                        line=dict(color=color, width=6),
                        name=f"{prefix} TF {axis_name}",
                        showlegend=show_leg,
                    )
                )

        _add_tf_axes(robot_xyz, robot_quat_xyzw, "robot")
        _add_tf_axes(nearest_ref_xyz, nearest_ref_quat_xyzw, "nearest ref")

        # Explicitly show which tags are in the camera optical pointing direction.
        pointing_tags = select_pointing_tags(
            robot_xyz,
            robot_quat_xyzw,
            pointing_tags_df if pointing_tags_df is not None else tags_df,
            forward_axis=forward_axis_for_pointing,
            top_k=4,
        )
        for i, (tag_name, p, ang) in enumerate(pointing_tags):
            tag_lbl = short_tag_label(tag_name)
            fig.add_trace(
                go.Scatter3d(
                    x=[robot_xyz[0], p[0]],
                    y=[robot_xyz[1], p[1]],
                    z=[robot_xyz[2], p[2]],
                    mode="lines",
                    line=dict(color="yellow", width=4),
                    name="pointing rays",
                    showlegend=(i == 0),
                    hovertemplate=f"pointing -> {tag_lbl}<br>angle={ang:.1f} deg<extra></extra>",
                )
            )
    else:
        # Student mode: only planar heading arrows (easy to interpret for control).
        hlen = 0.16
        rh = math.radians(robot_heading_deg)
        th = math.radians(ref_heading_deg)
        r_end = robot_xyz + np.array([math.cos(rh) * hlen, 0.0, math.sin(rh) * hlen], dtype=float)
        t_end = nearest_ref_xyz + np.array([math.cos(th) * hlen, 0.0, math.sin(th) * hlen], dtype=float)
        fig.add_trace(
            go.Scatter3d(
                x=[robot_xyz[0], r_end[0]],
                y=[robot_xyz[1], r_end[1]],
                z=[robot_xyz[2], r_end[2]],
                mode="lines",
                line=dict(color="royalblue", width=7),
                name="robot heading (planar)",
            )
        )
        fig.add_trace(
            go.Scatter3d(
                x=[nearest_ref_xyz[0], t_end[0]],
                y=[nearest_ref_xyz[1], t_end[1]],
                z=[nearest_ref_xyz[2], t_end[2]],
                mode="lines",
                line=dict(color="crimson", width=7),
                name="reference heading (planar)",
            )
        )

    dx = float(nearest_ref_xyz[0] - robot_xyz[0])
    dy = float(nearest_ref_xyz[1] - robot_xyz[1])
    dz = float(nearest_ref_xyz[2] - robot_xyz[2])
    didactic_rows = [
        ("Formula D", "sqrt((x_ref-x_robot)^2 + (y_ref-y_robot)^2 + (z_ref-z_robot)^2)"),
        (
            "Numeric D",
            f"sqrt(({nearest_ref_xyz[0]:.4f}-{robot_xyz[0]:.4f})^2 + ({nearest_ref_xyz[1]:.4f}-{robot_xyz[1]:.4f})^2 + ({nearest_ref_xyz[2]:.4f}-{robot_xyz[2]:.4f})^2)",
        ),
        ("Delta (ref-robot)", f"dx={dx:.4f}, dy={dy:.4f}, dz={dz:.4f}"),
        ("Result D [m]", f"{distance_m:.4f}"),
        ("Formula φ", "wrap_to_180(theta_robot - theta_ref)"),
        ("Numeric φ", f"wrap_to_180({robot_heading_deg:.2f} - {ref_heading_deg:.2f})"),
        ("Result φ [deg]", f"{heading_error_deg:.2f}"),
    ]
    table_rows = summary_rows + didactic_rows

    fig.add_trace(
        go.Table(
            header=dict(
                values=["Metric", "Value"],
                fill_color="#f6f8fa",
                align="left",
                font=dict(size=12),
            ),
            cells=dict(
                values=[[k for k, _ in table_rows], [v for _, v in table_rows]],
                align="left",
                height=22,
                font=dict(size=11),
            ),
            domain=dict(x=[0.0, 0.31], y=[0.0, 0.90]),
            name="summary",
        )
    )
    fig.update_layout(
        title="Robot Relocalization: Distance and Orientation vs Optimized Trajectory",
        scene=dict(
            xaxis_title="X [m]",
            yaxis_title="Y [m]",
            zaxis_title="Z [m]",
            aspectmode="data",
            domain=dict(x=[0.33, 0.995], y=[0.02, 0.98]),
            camera=dict(eye=dict(x=1.45, y=1.25, z=0.95)),
        ),
        annotations=[
            dict(
                x=0.01,
                y=0.98,
                xref="paper",
                yref="paper",
                text=(
                    f"<b>Distance:</b> {distance_m:.3f} m<br>"
                    f"<b>φ:</b> {heading_error_deg:.2f} deg"
                ),
                showarrow=False,
                align="left",
                bordercolor="rgba(0,0,0,0.2)",
                borderwidth=1,
                bgcolor="rgba(255,255,255,0.85)",
            )
        ],
        height=780,
        margin=dict(l=30, r=20, t=52, b=20),
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="right",
            x=0.995,
            bgcolor="rgba(255,255,255,0.7)",
            bordercolor="rgba(0,0,0,0.15)",
            borderwidth=1,
            font=dict(size=11),
        ),
    )
    fig.write_html(out_html, include_plotlyjs="cdn")


def write_point_vector_plot(
    out_pdf: str,
    out_svg: str,
    ref_xyz: np.ndarray,
    robot_xyz: np.ndarray,
    nearest_ref_xyz: np.ndarray,
    robot_heading_deg: float,
    ref_heading_deg: float,
    distance_m: float,
    heading_error_deg: float,
    robot_quat_xyzw: np.ndarray,
    tags_df: Optional[pd.DataFrame] = None,
    pointing_tags_df: Optional[pd.DataFrame] = None,
    forward_axis_for_pointing: str = "z",
    viz_mode: str = "student",
) -> None:
    ref_xz = ref_xyz[:, [0, 2]]
    robot_xz = robot_xyz[[0, 2]]
    nearest_xz = nearest_ref_xyz[[0, 2]]

    fig, ax = plt.subplots(figsize=(7.2, 6.0))
    ax.plot(ref_xz[:, 0], ref_xz[:, 1], color="black", linewidth=2.2, label="reference trajectory")

    if tags_df is not None and not tags_df.empty:
        tx = tags_df["x"].to_numpy(dtype=float)
        tz = tags_df["z"].to_numpy(dtype=float)
        ax.scatter(tx, tz, c="orange", s=26, label="tags", zorder=3)
        for row in tags_df.itertuples(index=False):
            ax.annotate(
                short_tag_label(str(row.tag)),
                xy=(float(row.x), float(row.z)),
                xytext=(0, 8),
                textcoords="offset points",
                fontsize=8,
                color="#3a4a6a",
                ha="center",
                va="bottom",
                zorder=3,
            )

    ax.scatter([robot_xz[0]], [robot_xz[1]], c="royalblue", s=85, label="robot", zorder=5)
    ax.scatter([nearest_xz[0]], [nearest_xz[1]], c="crimson", s=70, label="nearest on reference", zorder=5)
    ax.plot(
        [robot_xz[0], nearest_xz[0]],
        [robot_xz[1], nearest_xz[1]],
        color="darkorange",
        linewidth=2.0,
        linestyle="--",
        label="distance link",
        zorder=4,
    )

    span = np.linalg.norm(ref_xz.max(axis=0) - ref_xz.min(axis=0))
    arrow_len = max(0.08, 0.08 * float(span))
    r_h = math.radians(robot_heading_deg)
    t_h = math.radians(ref_heading_deg)
    rx2 = robot_xz[0] + arrow_len * math.cos(r_h)
    rz2 = robot_xz[1] + arrow_len * math.sin(r_h)
    tx2 = nearest_xz[0] + arrow_len * math.cos(t_h)
    tz2 = nearest_xz[1] + arrow_len * math.sin(t_h)
    ax.arrow(
        robot_xz[0], robot_xz[1], rx2 - robot_xz[0], rz2 - robot_xz[1],
        color="royalblue", width=0.0015, head_width=0.02, length_includes_head=True, zorder=6
    )
    ax.arrow(
        nearest_xz[0], nearest_xz[1], tx2 - nearest_xz[0], tz2 - nearest_xz[1],
        color="crimson", width=0.0015, head_width=0.02, length_includes_head=True, zorder=6
    )

    if viz_mode == "debug":
        # Draw rays to top pointing tags (computed from optical Z in 3D).
        pointing_tags = select_pointing_tags(
            robot_xyz,
            robot_quat_xyzw,
            pointing_tags_df if pointing_tags_df is not None else tags_df,
            forward_axis=forward_axis_for_pointing,
            top_k=4,
        )
        for tag_name, p3, ang in pointing_tags:
            p2 = np.array([p3[0], p3[2]], dtype=float)
            ax.plot(
                [robot_xz[0], p2[0]],
                [robot_xz[1], p2[1]],
                color="gold",
                linewidth=1.4,
                linestyle="-",
                zorder=4,
            )

    ax.text(
        0.02,
        0.98,
        f"d={distance_m:.3f} m\nangle={heading_error_deg:.2f} deg",
        transform=ax.transAxes,
        va="top",
        ha="left",
        fontsize=9,
        bbox=dict(boxstyle="round,pad=0.25", fc="white", ec="0.5", alpha=0.9),
        zorder=7,
    )

    ax.set_title("Point Relocalization vs Optimized Trajectory (Vector Plot)")
    ax.set_xlabel("X [m]")
    ax.set_ylabel("Z [m]")
    ax.axis("equal")
    ax.grid(alpha=0.28)
    ax.legend(loc="best", fontsize=8)
    fig.tight_layout()

    os.makedirs(os.path.dirname(out_pdf), exist_ok=True)
    fig.savefig(out_pdf, dpi=300)
    fig.savefig(out_svg)
    plt.close(fig)


def write_point_details_csv(
    out_csv: str,
    distance_m: float,
    phi_deg: float,
    robot_xyz: np.ndarray,
    nearest_ref_xyz: np.ndarray,
    robot_quat_xyzw: np.ndarray,
    nearest_ref_quat_xyzw: np.ndarray,
    robot_heading_deg: float,
    ref_heading_deg: float,
) -> None:
    os.makedirs(os.path.dirname(out_csv), exist_ok=True)
    robot_r, robot_p, robot_y = quat_xyzw_to_rpy_deg(robot_quat_xyzw)
    ref_r, ref_p, ref_y = quat_xyzw_to_rpy_deg(nearest_ref_quat_xyzw)
    dx = float(nearest_ref_xyz[0] - robot_xyz[0])
    dy = float(nearest_ref_xyz[1] - robot_xyz[1])
    dz = float(nearest_ref_xyz[2] - robot_xyz[2])

    with open(out_csv, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["metric", "value"])
        w.writerow(["distance_D_m", f"{distance_m:.6f}"])
        w.writerow(["heading_error_phi_deg", f"{phi_deg:.6f}"])
        w.writerow(["robot_heading_xz_deg", f"{robot_heading_deg:.6f}"])
        w.writerow(["reference_heading_xz_deg", f"{ref_heading_deg:.6f}"])
        w.writerow(["delta_x_ref_minus_robot_m", f"{dx:.6f}"])
        w.writerow(["delta_y_ref_minus_robot_m", f"{dy:.6f}"])
        w.writerow(["delta_z_ref_minus_robot_m", f"{dz:.6f}"])
        w.writerow(["robot_x_m", f"{float(robot_xyz[0]):.6f}"])
        w.writerow(["robot_y_m", f"{float(robot_xyz[1]):.6f}"])
        w.writerow(["robot_z_m", f"{float(robot_xyz[2]):.6f}"])
        w.writerow(["robot_qx", f"{float(robot_quat_xyzw[0]):.8f}"])
        w.writerow(["robot_qy", f"{float(robot_quat_xyzw[1]):.8f}"])
        w.writerow(["robot_qz", f"{float(robot_quat_xyzw[2]):.8f}"])
        w.writerow(["robot_qw", f"{float(robot_quat_xyzw[3]):.8f}"])
        w.writerow(["robot_roll_deg", f"{robot_r:.6f}"])
        w.writerow(["robot_pitch_deg", f"{robot_p:.6f}"])
        w.writerow(["robot_yaw_deg", f"{robot_y:.6f}"])
        w.writerow(["reference_x_m", f"{float(nearest_ref_xyz[0]):.6f}"])
        w.writerow(["reference_y_m", f"{float(nearest_ref_xyz[1]):.6f}"])
        w.writerow(["reference_z_m", f"{float(nearest_ref_xyz[2]):.6f}"])
        w.writerow(["reference_qx", f"{float(nearest_ref_quat_xyzw[0]):.8f}"])
        w.writerow(["reference_qy", f"{float(nearest_ref_quat_xyzw[1]):.8f}"])
        w.writerow(["reference_qz", f"{float(nearest_ref_quat_xyzw[2]):.8f}"])
        w.writerow(["reference_qw", f"{float(nearest_ref_quat_xyzw[3]):.8f}"])
        w.writerow(["reference_roll_deg", f"{ref_r:.6f}"])
        w.writerow(["reference_pitch_deg", f"{ref_p:.6f}"])
        w.writerow(["reference_yaw_deg", f"{ref_y:.6f}"])


def main() -> None:
    p = argparse.ArgumentParser(
        description=(
            "Analyze relocalization distance (D) and heading error (phi) "
            "relative to a reference trajectory."
        )
    )
    p.add_argument(
        "reference_input",
        help="Reference CSV or reference output directory (must contain trajetoria_camera.csv)",
    )
    p.add_argument(
        "query_input",
        help="Query CSV or query output directory (must contain trajetoria_camera.csv)",
    )
    p.add_argument("output_dir", help="Directory for output CSV and plot")
    p.add_argument(
        "--query-bag",
        default="",
        help="Optional query rosbag2 folder to extract tags actually detected at the analyzed timestamp",
    )
    p.add_argument(
        "--detections-topic",
        default="/detections",
        help="Detections topic used with --query-bag",
    )
    p.add_argument(
        "--query-tags-csv",
        default="",
        help="Optional query tags CSV (mapa_tags.csv). If omitted, tries <dir(query_csv)>/mapa_tags.csv",
    )
    p.add_argument(
        "--align",
        choices=["auto", "none", "tags"],
        default="auto",
        help="Frame alignment before metrics: auto=use tags when available, tags=force tags alignment, none=disable",
    )
    p.add_argument(
        "--align-model",
        choices=["similarity", "rigid"],
        default="similarity",
        help="tags alignment model: similarity=rotation+translation+scale, rigid=rotation+translation",
    )
    p.add_argument(
        "--align-ransac-thresh-m",
        type=float,
        default=0.10,
        help="RANSAC inlier threshold [m] for tag alignment",
    )
    p.add_argument(
        "--align-ransac-iters",
        type=int,
        default=300,
        help="RANSAC iterations for tag alignment",
    )
    p.add_argument(
        "--align-scale-min",
        type=float,
        default=0.90,
        help="Minimum accepted alignment scale when using tags alignment",
    )
    p.add_argument(
        "--align-scale-max",
        type=float,
        default=1.10,
        help="Maximum accepted alignment scale when using tags alignment",
    )
    p.add_argument(
        "--allow-bad-scale",
        action="store_true",
        help="Do not abort when alignment scale is outside [align-scale-min, align-scale-max]",
    )
    p.add_argument(
        "--tags-csv",
        default="",
        help="Optional map tags CSV (mapa_tags.csv). If omitted, tries <dir(reference_csv)>/mapa_tags.csv",
    )
    p.add_argument(
        "--tf-axis-len",
        type=float,
        default=0.12,
        help="TF axis length (meters) for robot/reference camera frames in 3D view",
    )
    p.add_argument(
        "--viz-mode",
        choices=["student", "debug"],
        default="debug",
        help="student=clean/control-oriented visualization, debug=show full TF and pointing rays",
    )
    p.add_argument(
        "--mode",
        choices=["auto", "trajectory", "point"],
        default="auto",
        help="auto=detect static capture and use single representative point, trajectory=use all samples, point=force single point",
    )
    p.add_argument(
        "--static-threshold-m",
        type=float,
        default=0.20,
        help="95th percentile radius threshold (m) used by --mode auto to classify static point capture",
    )
    p.add_argument(
        "--forward-axis",
        choices=["x", "z", "-x", "-z"],
        default="z",
        help="Local axis treated as robot forward for heading from quaternion",
    )
    args = p.parse_args()
    reference_csv = resolve_traj_input_path(args.reference_input)
    query_csv = resolve_traj_input_path(args.query_input)

    if not args.query_bag:
        inferred_bag = infer_query_bag_path(args.query_input)
        if inferred_bag:
            args.query_bag = inferred_bag

    ref_df = load_traj_csv(reference_csv)
    query_df = load_traj_csv(query_csv)
    ref_tags_df: Optional[pd.DataFrame] = None
    ref_tags_csv_path = args.tags_csv.strip()
    if not ref_tags_csv_path:
        auto_tags = os.path.join(os.path.dirname(os.path.abspath(reference_csv)), "mapa_tags.csv")
        if os.path.exists(auto_tags):
            ref_tags_csv_path = auto_tags
    if ref_tags_csv_path:
        try:
            ref_tags_df = load_tags_csv(ref_tags_csv_path)
        except Exception as e:
            print(f"Warning: could not load reference tags CSV '{ref_tags_csv_path}': {e}")
            ref_tags_df = None

    query_tags_df: Optional[pd.DataFrame] = None
    query_tags_csv_path = args.query_tags_csv.strip()
    if not query_tags_csv_path:
        auto_q_tags = os.path.join(os.path.dirname(os.path.abspath(query_csv)), "mapa_tags.csv")
        if os.path.exists(auto_q_tags):
            query_tags_csv_path = auto_q_tags
    if query_tags_csv_path:
        try:
            query_tags_df = load_tags_csv(query_tags_csv_path)
        except Exception as e:
            print(f"Warning: could not load query tags CSV '{query_tags_csv_path}': {e}")
            query_tags_df = None

    ref_xz = ref_df[["x", "z"]].to_numpy(dtype=float)
    ref_heading_rad = compute_ref_tangent_heading_xz(ref_xz)
    query_heading_rad = heading_from_quat_xz(query_df, args.forward_axis)

    query_xz = query_df[["x", "z"]].to_numpy(dtype=float)
    align_used = "none"
    align_common_tags = 0
    align_inliers = 0
    align_yaw_rad = 0.0
    align_scale = 1.0
    align_rms_m = float("nan")
    align_r2 = np.eye(2, dtype=float)
    align_r3 = np.eye(3, dtype=float)
    if args.align in ("auto", "tags") and ref_tags_df is not None and query_tags_df is not None:
        try:
            r2, t2, yaw2, s2, inlier_tags, rms_m, inliers_n = estimate_alignment_from_tags(
                ref_tags_df,
                query_tags_df,
                model=args.align_model,
                ransac_thresh_m=float(args.align_ransac_thresh_m),
                ransac_iters=int(args.align_ransac_iters),
            )
            align_common_tags = len(sorted(set(ref_tags_df["tag"].astype(str)).intersection(set(query_tags_df["tag"].astype(str)))))
            align_inliers = inliers_n
            query_xz = apply_similarity_2d(query_xz, r2, t2, s2)
            query_df = query_df.copy()
            query_df["x"] = query_xz[:, 0]
            query_df["z"] = query_xz[:, 1]
            query_heading_rad = normalize_angle_rad(rotate_heading_by_r2(query_heading_rad, r2))
            align_yaw_rad = float(yaw2)
            align_scale = float(s2)
            align_rms_m = float(rms_m)
            align_r2 = r2.copy()
            align_r3 = rot3_from_rigid2d(r2)
            align_used = "tags"
            if query_tags_df is not None:
                q_tags_xz = query_tags_df[["x", "z"]].to_numpy(dtype=float)
                q_tags_xz_a = apply_similarity_2d(q_tags_xz, r2, t2, s2)
                query_tags_df = query_tags_df.copy()
                query_tags_df["x"] = q_tags_xz_a[:, 0]
                query_tags_df["z"] = q_tags_xz_a[:, 1]
        except Exception as e:
            if args.align == "tags":
                raise
            print(f"Warning: tag alignment skipped: {e}")
    elif args.align == "tags":
        raise RuntimeError("Alignment mode 'tags' requested, but tags CSVs are missing.")

    if align_used == "tags":
        bad_scale = (align_scale < float(args.align_scale_min)) or (align_scale > float(args.align_scale_max))
        if bad_scale and not args.allow_bad_scale:
            raise RuntimeError(
                "Alignment scale out of accepted range: "
                f"{align_scale:.4f} not in [{args.align_scale_min:.3f}, {args.align_scale_max:.3f}]. "
                "Likely tag-size mismatch between reference and query map generation. "
                "Regenerate both maps with the same --tag-size (recommended: 0.20). "
                "Use --allow-bad-scale to bypass."
            )

    mode_used = args.mode
    if args.mode == "auto":
        mode_used = "point" if is_static_point_capture(query_xz, args.static_threshold_m) else "trajectory"
    if mode_used == "point":
        query_df, query_xz, query_heading_rad = reduce_query_to_representative_point(query_df, query_xz, query_heading_rad)

    nearest_idx = np.zeros(len(query_xz), dtype=int)
    nearest_ref_xz_override: Optional[np.ndarray] = None
    if mode_used == "point":
        proj_xz, seg_i, seg_u, dist_m, seg_heading = nearest_point_on_polyline_xz(query_xz[0], ref_xz)
        nearest_idx = np.array([seg_i], dtype=int)
        distance_m = np.array([dist_m], dtype=float)
        nearest_ref_heading_rad = np.array([seg_heading], dtype=float)
        heading_err_rad = normalize_angle_rad(query_heading_rad - nearest_ref_heading_rad)
        nearest_ref_xz_override = np.array([proj_xz], dtype=float)
    else:
        nearest_idx, distance_m = nearest_indices_and_distance(query_xz, ref_xz)
        nearest_ref_heading_rad = ref_heading_rad[nearest_idx]
        heading_err_rad = normalize_angle_rad(query_heading_rad - nearest_ref_heading_rad)

    query_heading_deg = np.degrees(query_heading_rad)
    ref_heading_deg = np.degrees(nearest_ref_heading_rad)
    angle_error_deg = np.degrees(heading_err_rad)
    abs_angle_error_deg = np.abs(angle_error_deg)

    stamp_ns = (
        query_df["stamp_sec"].to_numpy(dtype=np.int64) * np.int64(1_000_000_000)
        + query_df["stamp_nanosec"].to_numpy(dtype=np.int64)
    )
    t_rel_s = (stamp_ns - stamp_ns[0]).astype(float) * 1e-9

    out_csv = os.path.join(args.output_dir, "distance_angle_metrics.csv")
    out_html = os.path.join(args.output_dir, "distance_angle_analysis.html")
    out_vec_pdf = os.path.join(args.output_dir, "distance_angle_point_plot.pdf")
    out_vec_svg = os.path.join(args.output_dir, "distance_angle_point_plot.svg")
    out_point_csv = os.path.join(args.output_dir, "point_pose_didactic.csv")

    write_metrics_csv(
        out_csv,
        query_df,
        t_rel_s,
        nearest_idx,
        distance_m,
        query_heading_deg,
        ref_heading_deg,
        angle_error_deg,
        ref_xz,
        query_xz,
        nearest_ref_xz_override=nearest_ref_xz_override,
    )
    if mode_used == "point":
        nearest_idx0 = int(nearest_idx[0])
        if nearest_ref_xz_override is not None:
            nearest_point = nearest_ref_xz_override[0]
        else:
            nearest_point = ref_xz[nearest_idx0]
        robot_point = query_xz[0]
        ref_xyz = ref_df[["x", "y", "z"]].to_numpy(dtype=float)
        robot_xyz = np.array(
            [
                float(query_df.iloc[0]["x"]),
                float(query_df.iloc[0]["y"]),
                float(query_df.iloc[0]["z"]),
            ],
            dtype=float,
        )
        if nearest_ref_xz_override is not None and len(ref_xyz) >= 2:
            a3 = ref_xyz[nearest_idx0]
            b3 = ref_xyz[min(nearest_idx0 + 1, len(ref_xyz) - 1)]
            seg_len = np.linalg.norm(ref_xz[min(nearest_idx0 + 1, len(ref_xz) - 1)] - ref_xz[nearest_idx0])
            if seg_len > 1e-12:
                u3 = float(
                    np.linalg.norm(nearest_point - ref_xz[nearest_idx0]) / seg_len
                )
                u3 = max(0.0, min(1.0, u3))
            else:
                u3 = 0.0
            nearest_ref_xyz = (1.0 - u3) * a3 + u3 * b3
        else:
            nearest_ref_xyz = ref_xyz[nearest_idx0]
        robot_quat_raw = np.array(
            [
                float(query_df.iloc[0]["qx"]),
                float(query_df.iloc[0]["qy"]),
                float(query_df.iloc[0]["qz"]),
                float(query_df.iloc[0]["qw"]),
            ],
            dtype=float,
        )
        if align_used == "tags":
            q_align = quat_from_rotmat_xyzw(align_r3)
            robot_quat = quat_multiply_xyzw(q_align, robot_quat_raw)
        else:
            robot_quat = robot_quat_raw
        nearest_ref_quat = quat_from_yaw_about_y(float(nearest_ref_heading_rad[0]))
        chosen_forward_axis = args.forward_axis
        summary_rows = [
            ("Analysis mode", "point"),
            ("Frame alignment", align_used),
            ("Common tags for alignment", str(align_common_tags)),
            ("Alignment inliers", str(align_inliers)),
            ("Alignment model", args.align_model),
            ("Alignment scale", f"{align_scale:.4f}"),
            ("Alignment RMS [m]", f"{align_rms_m:.4f}" if not math.isnan(align_rms_m) else "n/a"),
            ("Visualization mode", args.viz_mode),
            ("Reference samples", str(len(ref_df))),
            ("Original query samples", str(len(load_traj_csv(query_csv)))),
            ("Representative query samples", "1"),
            ("Ref tags loaded", str(0 if ref_tags_df is None else len(ref_tags_df))),
            ("Pointing tags source", "query tags (aligned)" if query_tags_df is not None else "reference tags"),
            ("Forward axis used", chosen_forward_axis),
            ("Robot heading [deg]", f"{query_heading_deg[0]:.2f}"),
            ("Reference heading [deg]", f"{ref_heading_deg[0]:.2f}"),
            ("Robot point X [m]", f"{robot_point[0]:.4f}"),
            ("Robot point Y [m]", f"{robot_xyz[1]:.4f}"),
            ("Robot point Z [m]", f"{robot_point[1]:.4f}"),
            ("Nearest ref X [m]", f"{nearest_point[0]:.4f}"),
            ("Nearest ref Y [m]", f"{nearest_ref_xyz[1]:.4f}"),
            ("Nearest ref Z [m]", f"{nearest_point[1]:.4f}"),
        ]

        filtered_pointing_tags_df = query_tags_df
        if args.query_bag:
            try:
                ts = int(query_df.iloc[0]["stamp_sec"]) * 1_000_000_000 + int(query_df.iloc[0]["stamp_nanosec"])
                det_tags, det_stamp = load_detection_tags_near_stamp(args.query_bag, args.detections_topic, ts)
                summary_rows.append(("Detections at point (bag)", str(len(det_tags))))
                if det_stamp is not None:
                    summary_rows.append(("Detection stamp ns", str(det_stamp)))
                if query_tags_df is not None and det_tags:
                    keep = set(det_tags)
                    filtered_pointing_tags_df = query_tags_df[query_tags_df["tag"].astype(str).isin(keep)].copy()
                    summary_rows.append(("Pointing tags filtered", str(len(filtered_pointing_tags_df))))
                    summary_rows.append(("Pointing tags list", ",".join(sorted(filtered_pointing_tags_df['tag'].astype(str).tolist()))))
                elif det_tags and ref_tags_df is not None:
                    filtered_pointing_tags_df = ref_tags_df[ref_tags_df["tag"].astype(str).isin(set(det_tags))].copy()
                    summary_rows.append(("Pointing tags filtered", str(len(filtered_pointing_tags_df))))
                    summary_rows.append(("Pointing tags list", ",".join(sorted(filtered_pointing_tags_df['tag'].astype(str).tolist()))))
            except Exception as e:
                summary_rows.append(("Detections at point (bag)", f"unavailable ({e})"))

        if filtered_pointing_tags_df is not None and not filtered_pointing_tags_df.empty:
            inferred_axis, inferred_mean = infer_forward_axis_from_tags(robot_xyz, robot_quat, filtered_pointing_tags_df)
            chosen_forward_axis = inferred_axis
            qh_single = heading_from_quat_xz(pd.DataFrame([{
                "qx": robot_quat[0], "qy": robot_quat[1], "qz": robot_quat[2], "qw": robot_quat[3]
            }]), chosen_forward_axis)[0]
            qh_single_deg = float(np.degrees(qh_single))
            err_deg = float(((qh_single_deg - float(ref_heading_deg[0]) + 180.0) % 360.0) - 180.0)
            query_heading_deg[0] = qh_single_deg
            angle_error_deg[0] = err_deg
            summary_rows.append(("Inferred forward axis", f"{chosen_forward_axis} (mean tag angle={inferred_mean:.1f} deg)"))
        robot_r, robot_p, robot_y = quat_xyzw_to_rpy_deg(robot_quat)
        ref_r, ref_p, ref_y = quat_xyzw_to_rpy_deg(nearest_ref_quat)
        summary_rows.extend(
            [
                ("Robot quaternion [x y z w]", f"{robot_quat[0]:.4f}, {robot_quat[1]:.4f}, {robot_quat[2]:.4f}, {robot_quat[3]:.4f}"),
                ("Robot RPY [deg]", f"{robot_r:.2f}, {robot_p:.2f}, {robot_y:.2f}"),
                ("Reference quaternion [x y z w]", f"{nearest_ref_quat[0]:.4f}, {nearest_ref_quat[1]:.4f}, {nearest_ref_quat[2]:.4f}, {nearest_ref_quat[3]:.4f}"),
                ("Reference RPY [deg]", f"{ref_r:.2f}, {ref_p:.2f}, {ref_y:.2f}"),
            ]
        )
        if align_used == "tags":
            if not (0.80 <= align_scale <= 1.25):
                summary_rows.append(("Alignment warning", "scale far from 1.0 (possible tag-size mismatch)"))
            if not math.isnan(align_rms_m) and align_rms_m > 0.10:
                summary_rows.append(("Alignment warning", "high RMS (maps may be inconsistent)"))

        # Rewrite point metrics with the final forward-axis choice used for visualization.
        write_metrics_csv(
            out_csv,
            query_df,
            t_rel_s,
            nearest_idx,
            distance_m,
            query_heading_deg,
            ref_heading_deg,
            angle_error_deg,
            ref_xz,
            query_xz,
            nearest_ref_xz_override=nearest_ref_xz_override,
        )

        write_html_point_report(
            out_html,
            ref_xyz,
            robot_xyz,
            nearest_ref_xyz,
            float(query_heading_deg[0]),
            float(ref_heading_deg[0]),
            float(distance_m[0]),
            float(angle_error_deg[0]),
            summary_rows,
            robot_quat,
            nearest_ref_quat,
            tags_df=ref_tags_df,
            pointing_tags_df=filtered_pointing_tags_df,
            forward_axis_for_pointing=chosen_forward_axis,
            tf_axis_len_m=float(args.tf_axis_len),
            viz_mode=args.viz_mode,
        )
        write_point_vector_plot(
            out_vec_pdf,
            out_vec_svg,
            ref_xyz,
            robot_xyz,
            nearest_ref_xyz,
            float(query_heading_deg[0]),
            float(ref_heading_deg[0]),
            float(distance_m[0]),
            float(angle_error_deg[0]),
            robot_quat,
            tags_df=ref_tags_df,
            pointing_tags_df=filtered_pointing_tags_df,
            forward_axis_for_pointing=chosen_forward_axis,
            viz_mode=args.viz_mode,
        )
        write_point_details_csv(
            out_point_csv,
            float(distance_m[0]),
            float(angle_error_deg[0]),
            robot_xyz,
            nearest_ref_xyz,
            robot_quat,
            nearest_ref_quat,
            float(query_heading_deg[0]),
            float(ref_heading_deg[0]),
        )
    else:
        summary_rows = [
            ("Analysis mode", "trajectory"),
            ("Frame alignment", align_used),
            ("Common tags for alignment", str(align_common_tags)),
            ("Alignment inliers", str(align_inliers)),
            ("Alignment model", args.align_model),
            ("Alignment scale", f"{align_scale:.4f}"),
            ("Alignment RMS [m]", f"{align_rms_m:.4f}" if not math.isnan(align_rms_m) else "n/a"),
            ("Reference samples", str(len(ref_df))),
            ("Query samples", str(len(query_df))),
            ("Distance mean [m]", f"{distance_m.mean():.4f}"),
            ("Distance median [m]", f"{np.median(distance_m):.4f}"),
            ("Distance p95 [m]", f"{percentile(distance_m, 95):.4f}"),
            ("Distance max [m]", f"{distance_m.max():.4f}"),
            ("|Heading error| mean [deg]", f"{abs_angle_error_deg.mean():.2f}"),
            ("|Heading error| median [deg]", f"{np.median(abs_angle_error_deg):.2f}"),
            ("|Heading error| p95 [deg]", f"{percentile(abs_angle_error_deg, 95):.2f}"),
            ("|Heading error| max [deg]", f"{abs_angle_error_deg.max():.2f}"),
        ]
        write_html_report(
            out_html,
            t_rel_s,
            distance_m,
            angle_error_deg,
            abs_angle_error_deg,
            ref_xz,
            query_xz,
            nearest_idx,
            summary_rows,
        )

    print("Distance/Angle Analysis")
    print(f"- Reference input resolved: {reference_csv}")
    print(f"- Query input resolved: {query_csv}")
    if args.query_bag:
        print(f"- Query bag used: {args.query_bag}")
    print(f"- Mode used: {mode_used}")
    print(f"- Frame alignment: {align_used} (common tags={align_common_tags})")
    if align_used == "tags":
        print(f"- Alignment model: {args.align_model}")
        print(f"- Alignment inliers: {align_inliers}")
        print(f"- Alignment scale: {align_scale:.4f}")
        print(f"- Alignment RMS [m]: {align_rms_m:.4f}")
        if not (0.80 <= align_scale <= 1.25):
            print("- Warning: alignment scale far from 1.0 (possible tag-size mismatch)")
        if not math.isnan(align_rms_m) and align_rms_m > 0.10:
            print("- Warning: high alignment RMS (maps may be inconsistent)")
    print(f"- Reference samples: {len(ref_df)}")
    print(f"- Query samples used: {len(query_df)}")
    if mode_used == "point":
        print(f"- Distance to trajectory [m]: {distance_m[0]:.4f}")
        print(f"- Heading error [deg]: {angle_error_deg[0]:.2f}")
    else:
        print(f"- Distance mean [m]: {distance_m.mean():.4f}")
        print(f"- Distance median [m]: {np.median(distance_m):.4f}")
        print(f"- Distance p95 [m]: {percentile(distance_m, 95):.4f}")
        print(f"- Distance max [m]: {distance_m.max():.4f}")
        print(f"- |Heading error| mean [deg]: {abs_angle_error_deg.mean():.2f}")
        print(f"- |Heading error| median [deg]: {np.median(abs_angle_error_deg):.2f}")
        print(f"- |Heading error| p95 [deg]: {percentile(abs_angle_error_deg, 95):.2f}")
        print(f"- |Heading error| max [deg]: {abs_angle_error_deg.max():.2f}")
    print(f"- Output metrics CSV: {out_csv}")
    print(f"- Output interactive HTML: {out_html}")
    if mode_used == "point":
        print(f"- Output vector PDF: {out_vec_pdf}")
        print(f"- Output vector SVG: {out_vec_svg}")
        print(f"- Output didactic point CSV: {out_point_csv}")


if __name__ == "__main__":
    main()
